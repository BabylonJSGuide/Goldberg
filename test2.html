<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>mesh spli</title>

	<script src="babylon.max.js"></script>
	
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
if (BABYLON.Engine.isSupported()) {
    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);
	
var createScene = function () {
	var scene = new BABYLON.Scene(engine);
	//scene.debugLayer.show();

    var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene);
	var light1 = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, -1, 0), scene);
	
	light.intensity = 0.5;
	light1.intensity = 0.5;
    
	var camera = new BABYLON.ArcRotateCamera("camera1",  -Math.PI / 2, Math.PI / 2.2, 5, new BABYLON.Vector3(0, 0, 0), scene);
	camera.attachControl(canvas, true);
	  
	//var g = BABYLON.MeshBuilder.CreateGeodesicSphere("g", {m: 7, n: 2}, scene);
	var g = BABYLON.MeshBuilder.CreateGoldberg("g", {m: 12, n: 1, updatable: true}, scene);
	//console.log("univ", g._univSet);
	
	console.log("shared", g.nbSharedFaces, "by 12", g.nbSharedFaces / 12);
	console.log("unshared", g.nbUnsharedFaces);
	console.log("pole", g.nbFacesAtPole);
	
	
	
	const root3 = Math.sqrt(3);
	
	var face = 0;
	var count = 160;
	var adjCopy =g.adjacentFaces.concat([]);
	var visited = new Set();

	g.setFaceColors([[face, face, new BABYLON.Color4(0, 1, 0, 1)]]);
	var af = g.adjacentFaces[face];
	var ridx = Math.floor(Math.random() * af.length);
	visited.add(rf);
	var rf = af[ridx];
	af.splice(rf, 1);
	var i = 0;
	g.setFaceColors([[rf, rf, new BABYLON.Color4(1, 0, i / count, 1)]]);
	while ( i < count && af.length > 0) {
		face = rf;
		af = g.adjacentFaces[face];
		ridx = Math.floor(Math.random() * af.length);
		rf = af[ridx];
		af.splice(rf, 1);
		while (visited.has(rf)) {
			ridx = Math.floor(Math.random() * af.length);
			rf = af[ridx];
			af.splice(rf, 1);
		}
		i++;
		g.setFaceColors([[rf, rf, new BABYLON.Color4(1, 0, i / count, 1)]]);
	}
	

	//g.material = new BABYLON.StandardMaterial("");
	//g.material.diffuseTexture = new BABYLON.Texture("https://i.imgur.com/P0xexoA.jpg");

	return scene;
};

function showNormals(mesh, size, color, sc) {
    var normals = mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);
    var positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
    color = color || BABYLON.Color3.White();
    sc = sc || scene;
    size = size || 1;

    var lines = [];
    for (var i = 0; i < 44 * 8; i += 3) {
        var v1 = BABYLON.Vector3.FromArray(positions, i);
        var v2 = v1.add(BABYLON.Vector3.FromArray(normals, i).scaleInPlace(size));
        lines.push([v1.add(mesh.position), v2.add(mesh.position)]);
    }
    var normalLines = BABYLON.MeshBuilder.CreateLineSystem("normalLines", {lines: lines}, sc);
    normalLines.color = color;
    return normalLines;
}



var scene = createScene();

engine.runRenderLoop(function () {
  scene.render();

});

window.addEventListener("resize", function () {
    engine.resize();
});
        }
    </script>
</body>
</html>
