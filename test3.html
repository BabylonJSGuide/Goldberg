<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>mesh spli</title>

	<script src="babylon.max.js"></script>
	
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
if (BABYLON.Engine.isSupported()) {
    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);
	
var createScene = function () {
	var scene = new BABYLON.Scene(engine);
	//scene.debugLayer.show();

    var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene);
    
	var camera = new BABYLON.ArcRotateCamera("camera1",  -Math.PI / 2, Math.PI / 2.2, 5, new BABYLON.Vector3(0, 0, 0), scene);
	camera.attachControl(canvas, true);
	  
	//var g = BABYLON.MeshBuilder.CreateGeodesicSphere("g", {m: 7, n: 2}, scene);
	var g = BABYLON.MeshBuilder.CreateGoldberg("g", {m: 9, n: 3, updatable: true}, scene);
	//console.log("univ", g._univSet);
	
	console.log("shared", g.nbSharedFaces, "by 12", g.nbSharedFaces / 12);
	console.log("unshared", g.nbUnsharedFaces);
	console.log("pole", g.nbFacesAtPole);
	
	    const root3 = Math.sqrt(3);

    const nbAtPoles = g.nbFacesAtPole;
    const shared = g.nbSharedFaces;
    const sharedPerPole = Math.floor(shared / 12);
    const sharedExtra = new Array(12);
    sharedExtra.fill(0);
    for (let i = 0; i < shared % 12; i++) {
        sharedExtra[i] = 1;
    };
    const total = nbAtPoles + shared / 12;
    
	const a = 3;
	const b = (2 - 6 * root3);
	const c = -6 * root3 * total;
    let cols = (Math.sqrt(b * b - 4 * a * c) - b) / (2 * a);
    cols = Math.ceil(cols);
    
    const rows = Math.ceil((total + cols) / (2 * cols));

	const radius1 = 1 / (12 * root3 * rows);
	const radius2 = 1 / ( 2 + 3 * cols);
	const radius = Math.min(radius1, radius2);
  
    
    const rotate60 = Math.PI / 3;
    const rotate72 = 2 * Math.PI / 5;
    const rotate54 = 0.3 * Math.PI;


    const hexData = [];
    for (let i = 0; i < 6; i++) {
       hexData.push(radius * Math.cos(-rotate60 + i * rotate60), radius * Math.sin(-rotate60 + i * rotate60)); 
    }
    
    const pentData = [];
    for (let i = 0; i < 5; i++) {
       pentData.push(radius * Math.cos(-rotate54 + i * rotate72), radius * Math.sin(-rotate54 + i * rotate72)); 
    }

	const uvs = [];
	let center = BABYLON.Vector2.Zero();
	let totalCount = 0;
	let i = 0;
	
	g.setFaceUVs([[12, 50, new BABYLON.Vector2(0.5, 0.5), 0.25, 0]]);


	
/*	g.setFaceColors([
			[0, g.nbSharedFaces + g.nbUnsharedFaces, new BABYLON.Color4(1, 1, 1, 1)],
			[0, 11, new BABYLON.Color4(1, 0, 0, 1)],
			[12, 12 + g.nbFacesAtPole, new BABYLON.Color4(0, 1, 0, 1)]
			
			]); */
			
	//console.log("P", g.getVerticesData(BABYLON.VertexBuffer.PositionKind).length / 3);
	//console.log(g.getVerticesData(BABYLON.VertexBuffer.UVKind).length / 2, uvs.length / 2);
	
	g.updateVerticesData(BABYLON.VertexBuffer.UVKind, uvs);
	

	g.material = new BABYLON.StandardMaterial("");
	g.material.diffuseTexture = new BABYLON.Texture("https://i.imgur.com/E4O0crm.jpg");

	return scene;
};

function showNormals(mesh, size, color, sc) {
    var normals = mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);
    var positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
    color = color || BABYLON.Color3.White();
    sc = sc || scene;
    size = size || 1;

    var lines = [];
    for (var i = 0; i < 44 * 8; i += 3) {
        var v1 = BABYLON.Vector3.FromArray(positions, i);
        var v2 = v1.add(BABYLON.Vector3.FromArray(normals, i).scaleInPlace(size));
        lines.push([v1.add(mesh.position), v2.add(mesh.position)]);
    }
    var normalLines = BABYLON.MeshBuilder.CreateLineSystem("normalLines", {lines: lines}, sc);
    normalLines.color = color;
    return normalLines;
}



var scene = createScene();

engine.runRenderLoop(function () {
  scene.render();

});

window.addEventListener("resize", function () {
    engine.resize();
});
        }
    </script>
</body>
</html>
