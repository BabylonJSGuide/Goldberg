<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>mesh spli</title>

	<script src="babylon.max.js"></script>
	
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
if (BABYLON.Engine.isSupported()) {
    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);
	
var createScene = function () {
	var scene = new BABYLON.Scene(engine);
	//scene.debugLayer.show();

    var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene);
	var light1 = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, -1, 0), scene);
	
	light.intensity = 0.5;
	light1.intensity = 0.5;
    
	var camera = new BABYLON.ArcRotateCamera("camera1",  -Math.PI / 2, Math.PI / 2.2, 5, new BABYLON.Vector3(0, 0, 0), scene);
	camera.attachControl(canvas, true);
	  
	 
	  
	BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/BabylonJSGuide/Goldberg/main/", "goldbergTest.babylon").then((result) =>{
    const root = result.meshes[0];
	//console.log("root", root.getVerticesData(BABYLON.VertexBuffer.UVKind));
	//console.log("OV", root.metadata.faceXaxis[0]._x);
	//console.log("veccheck", new BABYLON.Vector3(root.metadata.faceXaxis[0]._x, root.metadata.faceXaxis[0]._y, root.metadata.faceXaxis[0]._z).scale(10));
	const metadata = root.metadata;
	const g = BABYLON.Mesh.ToGoldberg(root);
	g.metadata = metadata;
	g.refreshFaceData();
	//console.log("meta", g.metadata);
	//console.log("X", g.faceXaxis);
	//console.log("UV", g.getVerticesData(BABYLON.VertexBuffer.UVKind));
	
	  for (let f = 12; f < 12 + g.nbFacesAtPole ; f++) {
	const cyl = BABYLON.MeshBuilder.CreateBox("", {height: 1, size: 0.015});
		g.placeOnFaceAt(cyl, f, new BABYLON.Vector3(0, 0.55, 0));
	} 
	
	const root3 = Math.sqrt(3);
	
	radius = 1 / 2;
	let center = new BABYLON.Vector2(1 / 2, 1 / 2);
	
	uvset = [];
	
	uvset.push([0, g.nbSharedFaces + g.nbUnsharedFaces - 1, center.clone(), radius, 0]);
	
	for (let f = 12; f < g.nbSharedFaces + g.nbUnsharedFaces; f++) {
		uvset.push([f, f, center.clone(), radius, f * Math.PI / 3]);
	}
	
	center = new BABYLON.Vector2(1 / 8, 1 / 8);
	uvset.push([0, 11, center.clone(), 1 / 8, 0]);
	
	  
	g.setFaceUVs(uvset);
	
	
	//g.setFaceColors([[0, g.nbSharedFaces + g.nbUnsharedFaces - 1, new BABYLON.Color4(0, 0, 1, 1)]]);
	//g.setFaceColors([[12 + g.nbFacesAtPole, 12 + 2 * g.nbFacesAtPole, new BABYLON.Color4(0, 1, 1, 0.6)]]);
	
			
	

	//g.material = new BABYLON.StandardMaterial("");
	g.material.diffuseTexture = new BABYLON.Texture("https://i.imgur.com/P0xexoA.jpg");
    })


	return scene;
};

function showNormals(mesh, size, color, sc) {
    var normals = mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);
    var positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
    color = color || BABYLON.Color3.White();
    sc = sc || scene;
    size = size || 1;

    var lines = [];
    for (var i = 0; i < 44 * 8; i += 3) {
        var v1 = BABYLON.Vector3.FromArray(positions, i);
        var v2 = v1.add(BABYLON.Vector3.FromArray(normals, i).scaleInPlace(size));
        lines.push([v1.add(mesh.position), v2.add(mesh.position)]);
    }
    var normalLines = BABYLON.MeshBuilder.CreateLineSystem("normalLines", {lines: lines}, sc);
    normalLines.color = color;
    return normalLines;
}



var scene = createScene();

engine.runRenderLoop(function () {
  scene.render();

});

window.addEventListener("resize", function () {
    engine.resize();
});
        }
    </script>
</body>
</html>
